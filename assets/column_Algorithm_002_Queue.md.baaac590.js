import{_ as s,o as n,c as a,Q as l}from"./chunks/framework.98c15f2e.js";const u=JSON.parse('{"title":"详解队列在前端的应用，深剖JS中的事件循环Eventloop，再了解微任务和宏任务","description":"","frontmatter":{"title":"详解队列在前端的应用，深剖JS中的事件循环Eventloop，再了解微任务和宏任务","author":"周一","date":"2021-06-01","categories":["前端开发"],"tags":["数构与前端"],"sidebar":"auto"},"headers":[{"level":1,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":1,"title":"一、队列是什么","slug":"一、队列是什么","link":"#一、队列是什么","children":[]},{"level":1,"title":"二、应用场景","slug":"二、应用场景","link":"#二、应用场景","children":[]},{"level":1,"title":"三、前端与队列：事件循环与任务队列","slug":"三、前端与队列-事件循环与任务队列","link":"#三、前端与队列-事件循环与任务队列","children":[{"level":2,"title":"1、event loop","slug":"_1、event-loop","link":"#_1、event-loop","children":[]},{"level":2,"title":"2、JS 如何执行","slug":"_2、js-如何执行","link":"#_2、js-如何执行","children":[]},{"level":2,"title":"3、event loop 过程","slug":"_3、event-loop-过程","link":"#_3、event-loop-过程","children":[]},{"level":2,"title":"4、 DOM 事件和 event loop","slug":"_4、-dom-事件和-event-loop","link":"#_4、-dom-事件和-event-loop","children":[]},{"level":2,"title":"5、event loop 总结","slug":"_5、event-loop-总结","link":"#_5、event-loop-总结","children":[]}]},{"level":1,"title":"四、宏任务和微任务","slug":"四、宏任务和微任务","link":"#四、宏任务和微任务","children":[{"level":2,"title":"1、引例","slug":"_1、引例","link":"#_1、引例","children":[]},{"level":2,"title":"2、宏任务和微任务","slug":"_2、宏任务和微任务","link":"#_2、宏任务和微任务","children":[{"level":3,"title":"（1）常用的宏任务和微任务","slug":"_1-常用的宏任务和微任务","link":"#_1-常用的宏任务和微任务","children":[]},{"level":3,"title":"（2）宏任务和微任务的优先级","slug":"_2-宏任务和微任务的优先级","link":"#_2-宏任务和微任务的优先级","children":[]},{"level":3,"title":"（3）代码实现微任务和宏任务","slug":"_3-代码实现微任务和宏任务","link":"#_3-代码实现微任务和宏任务","children":[]},{"level":3,"title":"（4）event loop 和 DOM 渲染","slug":"_4-event-loop-和-dom-渲染","link":"#_4-event-loop-和-dom-渲染","children":[]},{"level":3,"title":"（5）微任务、宏任务和 DOM 渲染的关系","slug":"_5-微任务、宏任务和-dom-渲染的关系","link":"#_5-微任务、宏任务和-dom-渲染的关系","children":[]},{"level":3,"title":"（6）为何微任务更早","slug":"_6-为何微任务更早","link":"#_6-为何微任务更早","children":[]}]}]},{"level":1,"title":"五、结束语","slug":"五、结束语","link":"#五、结束语","children":[]}],"relativePath":"column/Algorithm/002_Queue.md","filePath":"column/Algorithm/002_Queue.md","lastUpdated":1723906346000}'),p={name:"column/Algorithm/002_Queue.md"},o=l(`<h1 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h1><p><code>队列</code> 在日常生活中的应用非常广泛，比如我们最熟悉不过的食堂排队打饭、击鼓传花等等问题。同时，它在前端中的应用也非常广泛，比如，事件循环 <code>Event loop</code> 、JS 异步中的任务队列。</p><p>所以呢，对于前端来说， <code>队列</code> 结构是一个必学的知识点。在接下来的这篇文章中，将讲解关于 <code>队列</code> 在前端中的应用。</p><h1 id="一、队列是什么" tabindex="-1">一、队列是什么 <a class="header-anchor" href="#一、队列是什么" aria-label="Permalink to &quot;一、队列是什么&quot;">​</a></h1><p>队列是一种<strong>先进先出</strong>（FIFO）的线性表。它只允许在表的<strong>一端</strong>进行插入，而在<strong>另一端</strong>删除元素。</p><h1 id="二、应用场景" tabindex="-1">二、应用场景 <a class="header-anchor" href="#二、应用场景" aria-label="Permalink to &quot;二、应用场景&quot;">​</a></h1><ul><li>需要先进先出的场景。</li><li>比如：食堂排队打饭、火车站排队买票、JS 异步中的任务队列、计算最近请求次数……。</li></ul><h1 id="三、前端与队列-事件循环与任务队列" tabindex="-1">三、前端与队列：事件循环与任务队列 <a class="header-anchor" href="#三、前端与队列-事件循环与任务队列" aria-label="Permalink to &quot;三、前端与队列：事件循环与任务队列&quot;">​</a></h1><h2 id="_1、event-loop" tabindex="-1">1、event loop <a class="header-anchor" href="#_1、event-loop" aria-label="Permalink to &quot;1、event loop&quot;">​</a></h2><p><code>event loop</code>，也被称为<strong>事件循环</strong>或<strong>事件轮询</strong>。因为 JS 是单线程运行的，且异步需要基于回调来实现，所以， <code>event loop</code> 就是异步回调的实现原理。</p><h2 id="_2、js-如何执行" tabindex="-1">2、JS 如何执行 <a class="header-anchor" href="#_2、js-如何执行" aria-label="Permalink to &quot;2、JS 如何执行&quot;">​</a></h2><p><strong>JS 在程序中的执行遵循以下规则：</strong></p><ul><li>从前到后，一行一行执行</li><li>如果某一行执行报错，则停止下面代码的执行</li><li>先把同步代码执行完，再执行异步</li></ul><p>一起来看一个实例：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Hi&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">cb1</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;cb1&#39;</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">//cb1 即callback回调函数</span></span>
<span class="line"><span style="color:#E1E4E8;">}, </span><span style="color:#79B8FF;">5000</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Bye&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//打印顺序：</span></span>
<span class="line"><span style="color:#6A737D;">//Hi</span></span>
<span class="line"><span style="color:#6A737D;">//Bye</span></span>
<span class="line"><span style="color:#6A737D;">//cb1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;Hi&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">cb1</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;cb1&#39;</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">//cb1 即callback回调函数</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">5000</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;Bye&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//打印顺序：</span></span>
<span class="line"><span style="color:#6A737D;">//Hi</span></span>
<span class="line"><span style="color:#6A737D;">//Bye</span></span>
<span class="line"><span style="color:#6A737D;">//cb1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>从上例代码中可以看到， <code>JS</code> 是先执行同步代码，所以先打印 <code>Hi</code> 和 <code>Bye</code> ，之后执行异步代码，打印出 <code>cb1</code> 。</p><p>以此代码为例，下面开始讲解 <code>event loop</code> 的过程。</p><h2 id="_3、event-loop-过程" tabindex="-1">3、event loop 过程 <a class="header-anchor" href="#_3、event-loop-过程" aria-label="Permalink to &quot;3、event loop 过程&quot;">​</a></h2><p>对于上面这段代码，执行过程如下图所示。</p><p><img src="https://mondaylab-1309616765.cos.ap-shanghai.myqcloud.com/images/202304151117029.gif" alt="在这里插入图片描述"></p><p>从上图中可以分析出这段代码的运行轨迹。首先 <code>console.log(&#39;Hi&#39;)</code> 是同步代码，直接执行并打印出 <code>Hi</code> 。接下来继续执行定时器 <code>setTimeout</code> ，定时器是异步代码，所以这个时候浏览器会将它交给 <code>Web APIs</code> 来处理这件事情，因此先把它放到 <code>Web APIs</code> 中，之后继续执行 <code>console.log(&#39;Bye&#39;)</code> ， <code>console.log(&#39;Bye&#39;)</code> 是同步代码，在调用堆栈 <code>Call Stack</code> 中执行，打印出 <code>Bye</code> 。</p><p>到这里，调用堆栈 <code>Call Stack</code> 里面的内容全部执行完毕，当调用堆栈的内容为空时，浏览器就会开始去任务队列寻找下一个任务，此时任务队列就会去 <code>Web API</code> 里面寻找任务，遵循先进先出原则，找到了定时器，且定时器里面是回调函数 <code>cb1</code> ，于是把回调函数 <code>cb1</code> 传入任务队列中，此时 <code>Web API</code> 也空了，任务队列里面的任务就会传入到调用堆栈里<code>Call Stack</code> 里执行，最终打印出 <code>cb1</code> 。</p><h2 id="_4、-dom-事件和-event-loop" tabindex="-1">4、 DOM 事件和 event loop <a class="header-anchor" href="#_4、-dom-事件和-event-loop" aria-label="Permalink to &quot;4、 DOM 事件和 event loop&quot;">​</a></h2><p>先来看两段代码。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Hi&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">cb1</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;cb1&#39;</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">//cb 即 callback</span></span>
<span class="line"><span style="color:#E1E4E8;">}, </span><span style="color:#79B8FF;">5000</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Bye&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/*</span></span>
<span class="line"><span style="color:#6A737D;"> 输出结果：</span></span>
<span class="line"><span style="color:#6A737D;">Hi</span></span>
<span class="line"><span style="color:#6A737D;">Bye</span></span>
<span class="line"><span style="color:#6A737D;">cb1</span></span>
<span class="line"><span style="color:#6A737D;">*/</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;Hi&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">cb1</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;cb1&#39;</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">//cb 即 callback</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">5000</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;Bye&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/*</span></span>
<span class="line"><span style="color:#6A737D;"> 输出结果：</span></span>
<span class="line"><span style="color:#6A737D;">Hi</span></span>
<span class="line"><span style="color:#6A737D;">Bye</span></span>
<span class="line"><span style="color:#6A737D;">cb1</span></span>
<span class="line"><span style="color:#6A737D;">*/</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">button</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">id</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;btn1&quot;</span><span style="color:#E1E4E8;">&gt;提交&lt;/</span><span style="color:#85E89D;">button</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Hi&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  document.</span><span style="color:#B392F0;">getElementById</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;btn1&#39;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">click</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;button clicked&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Bye&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">/* 输出结果： Hi Bye button clicked */</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">button</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">id</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;btn1&quot;</span><span style="color:#24292E;">&gt;提交&lt;/</span><span style="color:#22863A;">button</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;Hi&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;btn1&#39;</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">click</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;button clicked&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;Bye&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">/* 输出结果： Hi Bye button clicked */</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>以上这两段代码中，第一段是关于 <code>setTimeout</code> 的事件循环，第二段是关于 <code>DOM</code> 事件的事件循环。那有小伙伴就会有疑问说， <code>DOM</code> 事件不是异步操作吗，为什么输出结果依然是在最后呢？</p><p>其实， <code>DOM</code> 事件确实不是异步操作，但是它也使用<strong>回调</strong>，基于 <code>event loop</code> 事件循环机制，所以当我们点击的时候，会触发 <code>DOM</code> 事件，并进行打印。</p><p>总结下 <code>DOM</code> 事件和 <code>event loop</code> 的区别：</p><ul><li><code>JS</code> 是单线程的；</li><li>异步（ <code>setTimeout</code> ， <code>ajax</code> 等）使用回调，基于 <code>event loop</code> ；</li><li><code>DOM</code> 事件不是异步，但也使用回调，基于 <code>event loop</code> 。</li></ul><h2 id="_5、event-loop-总结" tabindex="-1">5、event loop 总结 <a class="header-anchor" href="#_5、event-loop-总结" aria-label="Permalink to &quot;5、event loop 总结&quot;">​</a></h2><p>初阶认识完 event loop 后，来做个总结：</p><p><strong>总结 event loop 过程 1</strong></p><ul><li>同步代码，一行一行放在 <code>Call Stack</code> 执行；</li><li>遇到异步，会先“记录”下，等待时机（定时、网络请求）；</li><li>时机到了，就移动到 <code>Callback Queue</code>。</li></ul><p><strong>总结 event loop 过程 2</strong></p><ul><li>如果 <code>Call Stack</code> 为空（即同步代码执行完），则 <code>event Loop</code> 开始工作；</li><li>轮询查找 <code>Callback Queue</code> ，如果有则移动到 <code>Call Stack</code> 执行；</li><li>然后继续轮询查找（跟永动机一样，不断循环查找）。</li></ul><h1 id="四、宏任务和微任务" tabindex="-1">四、宏任务和微任务 <a class="header-anchor" href="#四、宏任务和微任务" aria-label="Permalink to &quot;四、宏任务和微任务&quot;">​</a></h1><h2 id="_1、引例" tabindex="-1">1、引例 <a class="header-anchor" href="#_1、引例" aria-label="Permalink to &quot;1、引例&quot;">​</a></h2><p>我们先来看一段代码。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">200</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#79B8FF;">Promise</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">resolve</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">300</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">400</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * 打印结果：</span></span>
<span class="line"><span style="color:#6A737D;"> * 100</span></span>
<span class="line"><span style="color:#6A737D;"> * 400</span></span>
<span class="line"><span style="color:#6A737D;"> * 300</span></span>
<span class="line"><span style="color:#6A737D;"> * 200</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">100</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">200</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"><span style="color:#005CC5;">Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">300</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">400</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * 打印结果：</span></span>
<span class="line"><span style="color:#6A737D;"> * 100</span></span>
<span class="line"><span style="color:#6A737D;"> * 400</span></span>
<span class="line"><span style="color:#6A737D;"> * 300</span></span>
<span class="line"><span style="color:#6A737D;"> * 200</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>在上面这段代码中，第一个和第二个打印结果是基于同步，我们都知道要打印 <code>100</code> 和 <code>400</code> ，但是第三个和第四个打印结果，理论上按照打印顺序应该是 <code>200</code> 和 <code>300</code> 才是，为什么是打印 <code>300</code> 和 <code>200</code> 呢？这就涉及到一个<strong>宏任务和微任务的问题</strong>。接下来将对宏任务和微任务进行讲解。</p><h2 id="_2、宏任务和微任务" tabindex="-1">2、宏任务和微任务 <a class="header-anchor" href="#_2、宏任务和微任务" aria-label="Permalink to &quot;2、宏任务和微任务&quot;">​</a></h2><h3 id="_1-常用的宏任务和微任务" tabindex="-1">（1）常用的宏任务和微任务 <a class="header-anchor" href="#_1-常用的宏任务和微任务" aria-label="Permalink to &quot;（1）常用的宏任务和微任务&quot;">​</a></h3><table><thead><tr><th>名称</th><th>举例（常用）</th></tr></thead><tbody><tr><td>宏任务</td><td>script、setTimeout 、setInterval 、setImmediate、Ajax、DOM 事件、I/O、UI Rendering</td></tr><tr><td>微任务</td><td>process.nextTick()、Promise、async/await</td></tr></tbody></table><p>上述的 <code>setTimeout</code> 和 <code>setInterval</code> 等都是任务源，真正进入任务队列的是他们分发的任务。</p><p><strong>注意：</strong> 微任务执行时机比宏任务要早！！</p><h3 id="_2-宏任务和微任务的优先级" tabindex="-1">（2）宏任务和微任务的优先级 <a class="header-anchor" href="#_2-宏任务和微任务的优先级" aria-label="Permalink to &quot;（2）宏任务和微任务的优先级&quot;">​</a></h3><p><strong>优先级</strong></p><ul><li>setTimeout = setInterval 一个队列</li><li>setTimeout &gt; setImmediate</li><li>process.nextTick &gt; Promise</li></ul><h3 id="_3-代码实现微任务和宏任务" tabindex="-1">（3）代码实现微任务和宏任务 <a class="header-anchor" href="#_3-代码实现微任务和宏任务" aria-label="Permalink to &quot;（3）代码实现微任务和宏任务&quot;">​</a></h3><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">macroTask</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> macroTaskQueue) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">handleMacroTask</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">microTask</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> microTaskQueue) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">handleMicroTask</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">macroTask</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">of</span><span style="color:#24292E;"> macroTaskQueue) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">handleMacroTask</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">microTask</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">of</span><span style="color:#24292E;"> microTaskQueue) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">handleMicroTask</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_4-event-loop-和-dom-渲染" tabindex="-1">（4）event loop 和 DOM 渲染 <a class="header-anchor" href="#_4-event-loop-和-dom-渲染" aria-label="Permalink to &quot;（4）event loop 和 DOM 渲染&quot;">​</a></h3><p>在上面的<strong>主题三第 4 点</strong>中讲过， <code>DOM</code> 事件基于回调，也是基于 <code>event loop</code> 机制的。那 DOM 事件在程序执行到什么时候，才会渲染呢？</p><p>同样来看这段代码。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">button</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">id</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;btn1&quot;</span><span style="color:#E1E4E8;">&gt;提交&lt;/</span><span style="color:#85E89D;">button</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.log(&#39;Hi&#39;);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    document.getElementById(&#39;btn1&#39;).click(function(e){</span></span>
<span class="line"><span style="color:#E1E4E8;">        console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;button clicked&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    console.log(&#39;Bye&#39;);</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/*</span></span>
<span class="line"><span style="color:#6A737D;"> 输出结果：</span></span>
<span class="line"><span style="color:#6A737D;">Hi</span></span>
<span class="line"><span style="color:#6A737D;">Bye</span></span>
<span class="line"><span style="color:#6A737D;">button clicked</span></span>
<span class="line"><span style="color:#6A737D;">*/</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">button</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">id</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;btn1&quot;</span><span style="color:#24292E;">&gt;提交&lt;/</span><span style="color:#22863A;">button</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    console.log(&#39;Hi&#39;);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    document.getElementById(&#39;btn1&#39;).click(function(e){</span></span>
<span class="line"><span style="color:#24292E;">        console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;button clicked&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    console.log(&#39;Bye&#39;);</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/*</span></span>
<span class="line"><span style="color:#6A737D;"> 输出结果：</span></span>
<span class="line"><span style="color:#6A737D;">Hi</span></span>
<span class="line"><span style="color:#6A737D;">Bye</span></span>
<span class="line"><span style="color:#6A737D;">button clicked</span></span>
<span class="line"><span style="color:#6A737D;">*/</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p><img src="https://mondaylab-1309616765.cos.ap-shanghai.myqcloud.com/images/202304151118582.png" alt="event loop 和 DOM渲染"></p><p>由上图可知，当程序调用栈空闲时，程序会先尝试去进行 <code>DOM</code> 渲染，最后再触发 <code>Event Loop</code> 机制。所以，在上面的这段代码中，程序会先打印同步代码 <code>Hi</code> 和 <code>Bye</code> ，等待同步代码打印完毕后，会再查找 <code>DOM</code> 事件，进行渲染，最后再触发 <code>event loop</code> 。</p><p>总结 <code>event loop</code> 和 <code>DOM</code> 渲染的关系：</p><ul><li><p>在程序执行的时候， <code>JS</code> 是单线程的，且和 <code>DOM</code> 渲染共用一个线程；</p></li><li><p>所以 <code>JS</code> 在执行的时候，得留一些时机提供给 <code>DOM</code> 渲染。</p></li><li><p>每次 <code>Call Stack</code> 清空（即每次轮询结束），表示同步任务执行完成；</p></li><li><p>程序会一直给 <code>DOM</code> 重新渲染的机会， <code>DOM</code> 结构如有改变则重新渲染；</p></li><li><p>然后再去触发下一次 <code>Event Loop</code> 。</p></li></ul><h3 id="_5-微任务、宏任务和-dom-渲染的关系" tabindex="-1">（5）微任务、宏任务和 DOM 渲染的关系 <a class="header-anchor" href="#_5-微任务、宏任务和-dom-渲染的关系" aria-label="Permalink to &quot;（5）微任务、宏任务和 DOM 渲染的关系&quot;">​</a></h3><p>先了解微任务、宏任务和 <code>DOM</code> 渲染的关系：</p><ul><li><strong>宏任务：</strong> <code>DOM</code> 渲染<strong>后</strong>触发，如 <code>setTimeout</code> 。</li><li><strong>微任务：</strong> <code>DOM</code> 渲染<strong>前</strong>触发，如 <code>Promise</code> 。</li></ul><p>我们先来演示现象，再追究其原理。</p><p><strong>1）演示 1</strong></p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">$p1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;&lt;p&gt;一段文字&lt;/p&gt;&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">$p2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;&lt;p&gt;一段文字&lt;/p&gt;&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">$p3</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;&lt;p&gt;一段文字&lt;/p&gt;&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;#container&#39;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">append</span><span style="color:#E1E4E8;">($p1).</span><span style="color:#B392F0;">append</span><span style="color:#E1E4E8;">($p2).</span><span style="color:#B392F0;">append</span><span style="color:#E1E4E8;">($p3);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//微任务：DOM 渲染前触发</span></span>
<span class="line"><span style="color:#79B8FF;">Promise</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">resolve</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;length&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;#container&#39;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">children</span><span style="color:#E1E4E8;">().</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">alert</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Promise then&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">//(alert 会阻断 js 执行， 也会阻断 DOM 渲染，便于查看效果)</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">$p1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">$</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;&lt;p&gt;一段文字&lt;/p&gt;&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">$p2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">$</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;&lt;p&gt;一段文字&lt;/p&gt;&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">$p3</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">$</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;&lt;p&gt;一段文字&lt;/p&gt;&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6F42C1;">$</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;#container&#39;</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">append</span><span style="color:#24292E;">($p1).</span><span style="color:#6F42C1;">append</span><span style="color:#24292E;">($p2).</span><span style="color:#6F42C1;">append</span><span style="color:#24292E;">($p3);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//微任务：DOM 渲染前触发</span></span>
<span class="line"><span style="color:#005CC5;">Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;length&#39;</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">$</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;#container&#39;</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">children</span><span style="color:#24292E;">().</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">alert</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;Promise then&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//(alert 会阻断 js 执行， 也会阻断 DOM 渲染，便于查看效果)</span></span>
<span class="line"><span style="color:#24292E;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>以上这段代码中，浏览器显示效果如下。</p><p><img src="https://img-blog.csdnimg.cn/20210520164020196.gif#pic_center" alt="微任务"></p><p>在图中可以看出，微任务 <code>promise</code> 在 <code>DOM</code> 渲染前就触发了，所以 <code>DOM</code> 对应的文字还没显示时， <code>Promise</code> 就已经打印。</p><p><strong>2）演示 2</strong></p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">$p1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;&lt;p&gt;一段文字&lt;/p&gt;&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">$p2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;&lt;p&gt;一段文字&lt;/p&gt;&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">$p3</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;&lt;p&gt;一段文字&lt;/p&gt;&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;#container&#39;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">append</span><span style="color:#E1E4E8;">($p1).</span><span style="color:#B392F0;">append</span><span style="color:#E1E4E8;">($p2).</span><span style="color:#B392F0;">append</span><span style="color:#E1E4E8;">($p3);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//宏任务：DOM 渲染后触发</span></span>
<span class="line"><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;length1&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;#container&#39;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">children</span><span style="color:#E1E4E8;">().</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">alert</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;SetTimeout&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">//(alert 会阻断 js 执行， 也会阻断 DOM 渲染，便于查看效果)</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">$p1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">$</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;&lt;p&gt;一段文字&lt;/p&gt;&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">$p2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">$</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;&lt;p&gt;一段文字&lt;/p&gt;&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">$p3</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">$</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;&lt;p&gt;一段文字&lt;/p&gt;&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6F42C1;">$</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;#container&#39;</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">append</span><span style="color:#24292E;">($p1).</span><span style="color:#6F42C1;">append</span><span style="color:#24292E;">($p2).</span><span style="color:#6F42C1;">append</span><span style="color:#24292E;">($p3);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//宏任务：DOM 渲染后触发</span></span>
<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;length1&#39;</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">$</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;#container&#39;</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">children</span><span style="color:#24292E;">().</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">alert</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;SetTimeout&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//(alert 会阻断 js 执行， 也会阻断 DOM 渲染，便于查看效果)</span></span>
<span class="line"><span style="color:#24292E;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>以上这段代码中，浏览器显示效果如下。</p><p><img src="https://mondaylab-1309616765.cos.ap-shanghai.myqcloud.com/images/202304151118083.gif" alt="宏任务"></p><p>在图中可以看出，当 <code>DOM</code> 对应的文字已经显示时， <code>setTimeout</code> 弹框才出现，所以宏任务 <code>setTimeout</code> 是在 <code>DOM</code> 渲染后（即 <code>DOM</code> 渲染并显示结束）才触发。</p><p>讲到这里，回到我们前面所说的知识点。</p><ul><li><strong>宏任务：</strong> <code>DOM</code> 渲染<strong>后</strong>触发，如 <code>setTimeout</code> 。</li><li><strong>微任务：</strong> <code>DOM</code> 渲染<strong>前</strong>触发，如 <code>Promise</code> 。</li></ul><p>从上面的演示后，相信大家应该明白了微任务、宏任务和 <code>DOM</code> 的关系。在第一个演示中，微任务 <code>Promise</code> 在 <code>DOM</code> 还没有渲染时就触发了，所以微任务都是在 <code>DOM</code> 渲染前触发。在第二个演示中，宏任务 <code>setTimeout</code> 在文字显示结束后才触发 <code>alert</code> ，所以微任务都是在 <code>DOM</code> 渲染后才进行触发。</p><h3 id="_6-为何微任务更早" tabindex="-1">（6）为何微任务更早 <a class="header-anchor" href="#_6-为何微任务更早" aria-label="Permalink to &quot;（6）为何微任务更早&quot;">​</a></h3><p>理解完微任务和宏任务与 DOM 的关系后，我们也大致基本了解了为什么微任务比宏任务更早。接下来我们在从 <code>eventloop</code> 层面来看，为什么微任务会比宏任务更早，为什么会在 DOM 渲染前就开始触发呢？</p><p>先用一张图来表示。</p><p><img src="https://mondaylab-1309616765.cos.ap-shanghai.myqcloud.com/images/202304151118524.png" alt="微任务宏任务"></p><p>微任务在执行时不会经过 <code>Web APIs</code> ，它会把它放到一个叫做 micro task queue<code> （即宏任务队列）当中。且微任务是</code>ES6\` 语法规定的，宏任务是由浏览器规定的，所以它会比宏任务更早。</p><p>到这里，我们讲完了 <code>event loop</code> 以及与其相关的宏任务和微任务，下面我们再用一张图来总结实际运用的执行顺序。</p><p><img src="https://img-blog.csdnimg.cn/20210520164145692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgwMzc1Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="微任务宏任务"></p><p><strong>从上图中可以得出结论：</strong></p><p><strong>第一步</strong>，程序先程序 <code>Call Stack</code> 里面的内容，待 <code>Call Stack</code> 清空时，执行当前的微任务；</p><p><strong>第二步</strong>，程序找到微任务队列的任务，执行微任务；</p><p><strong>第三步</strong>，待微任务执行完毕后，尝试执行 DOM 渲染；</p><p><strong>第四步</strong>， <code>DOM</code> 渲染结束后，触发 <code>event loop</code> ，执行宏任务。</p><h1 id="五、结束语" tabindex="-1">五、结束语 <a class="header-anchor" href="#五、结束语" aria-label="Permalink to &quot;五、结束语&quot;">​</a></h1><p>队列在前端中的应用可以算是很非常频繁了。基本上我们写的异步函数在执行过程中，都会涉及到事件循环问题。且在前端的面试当中，经常会被问到 <code>event loop</code> 、事件循环或者事件轮询是什么，很多面试者就很容易在这块内容吃亏。相信通过上文的学习，大家都对 <code>eventloop</code> 、微任务和宏任务有了一个更深的认识。</p><p>队列在前端中的应用就讲到这里啦！</p>`,91),e=[o];function c(t,r,i,E,y,d){return n(),a("div",null,e)}const g=s(p,[["render",c]]);export{u as __pageData,g as default};
