import{_ as t,o as r,c as o,Q as n}from"./chunks/framework.98c15f2e.js";const u=JSON.parse('{"title":"『软件测试2』 关于黑盒测试和测试用例的基础知识","description":"","frontmatter":{"title":"『软件测试2』 关于黑盒测试和测试用例的基础知识","author":"周一","date":"2021-06-01","categories":["产品汪"],"tags":["软件测试"],"sidebar":"auto"},"headers":[{"level":1,"title":"一、黑盒测试的基本概念","slug":"一、黑盒测试的基本概念","link":"#一、黑盒测试的基本概念","children":[{"level":2,"title":"1、黑盒测试基本概念","slug":"_1、黑盒测试基本概念","link":"#_1、黑盒测试基本概念","children":[]},{"level":2,"title":"2、黑盒测试错误类型","slug":"_2、黑盒测试错误类型","link":"#_2、黑盒测试错误类型","children":[]}]},{"level":1,"title":"二、测试用例概述及设计方法","slug":"二、测试用例概述及设计方法","link":"#二、测试用例概述及设计方法","children":[{"level":2,"title":"1、测试用例概述","slug":"_1、测试用例概述","link":"#_1、测试用例概述","children":[]},{"level":2,"title":"2、测试用例的好处","slug":"_2、测试用例的好处","link":"#_2、测试用例的好处","children":[]}]},{"level":1,"title":"三、黑盒测试方法","slug":"三、黑盒测试方法","link":"#三、黑盒测试方法","children":[]}],"relativePath":"column/Product/SoftwareTesting/002.md","filePath":"column/Product/SoftwareTesting/002.md","lastUpdated":1644826256000}'),s={name:"column/Product/SoftwareTesting/002.md"},e=n('<h1 id="一、黑盒测试的基本概念" tabindex="-1">一、黑盒测试的基本概念 <a class="header-anchor" href="#一、黑盒测试的基本概念" aria-label="Permalink to &quot;一、黑盒测试的基本概念&quot;">​</a></h1><h2 id="_1、黑盒测试基本概念" tabindex="-1">1、黑盒测试基本概念 <a class="header-anchor" href="#_1、黑盒测试基本概念" aria-label="Permalink to &quot;1、黑盒测试基本概念&quot;">​</a></h2><p>（<strong>1</strong>）所谓黑盒测试，就是把软件（程序）当作一个有输入与输出的黑匣子，它把程序当作一个<strong>输入域</strong>到<strong>输出域</strong>的映射，只要输入的数据能输出预期的结果即可，不需要了解程序的<strong>内部逻辑结构</strong>和<strong>内部特性</strong>。</p><p>（<strong>2</strong>）黑盒测试又称为<strong>功能测试</strong>或<strong>数据驱动测试</strong>。</p><p>（<strong>3</strong>）注重于程序的<strong>外部结构</strong>，主要对<u>软件功能要求、软件界面、外部数据库访问及软件初始化等方面进行测试</u>。测试者只要从程序<strong>接口</strong>处进行测试，以<strong>用户需求规格说明书</strong>为测试依据，测试程序是否满足用户的需求，因此是从<strong>用户观点</strong>出发的测试。</p><h2 id="_2、黑盒测试错误类型" tabindex="-1">2、黑盒测试错误类型 <a class="header-anchor" href="#_2、黑盒测试错误类型" aria-label="Permalink to &quot;2、黑盒测试错误类型&quot;">​</a></h2><p>黑盒测试主要发现的<strong>错误类型</strong>有：</p><p>（<strong>1</strong>）检测<strong>功能</strong>是否正确或有遗漏；</p><p>（<strong>2</strong>）检测<strong>性能</strong>是否满足要求；</p><p>（<strong>3</strong>）检测<strong>界面</strong>是否有错误；</p><p>（<strong>4</strong>）检测<strong>外部数据库访问</strong>是否有错误；</p><p>（<strong>5</strong>）检测<strong>程序初始化和终止方面</strong>是否有错误。</p><h1 id="二、测试用例概述及设计方法" tabindex="-1">二、测试用例概述及设计方法 <a class="header-anchor" href="#二、测试用例概述及设计方法" aria-label="Permalink to &quot;二、测试用例概述及设计方法&quot;">​</a></h1><h2 id="_1、测试用例概述" tabindex="-1">1、测试用例概述 <a class="header-anchor" href="#_1、测试用例概述" aria-label="Permalink to &quot;1、测试用例概述&quot;">​</a></h2><p>（<strong>1</strong>）是将软件测试的<strong>行为活动</strong>，做一个科学化的组织归纳。</p><p>（<strong>2</strong>）设计一个情况，软件程序在这种情况下，必须能够正常运行并且达到程序所设计的执行结果。</p><h2 id="_2、测试用例的好处" tabindex="-1">2、测试用例的好处 <a class="header-anchor" href="#_2、测试用例的好处" aria-label="Permalink to &quot;2、测试用例的好处&quot;">​</a></h2><p>（<strong>1</strong>）可以避免<strong>盲目测试</strong>并提高测试效率。</p><p>（<strong>2</strong>）令软件测试的实施重点突出、目的明确。</p><p>（<strong>3</strong>）软件版本更新后，只需少量修正便可进行测试，<strong>降低工作强度</strong>，<strong>缩短项目周期</strong>。</p><p>（<strong>4</strong>）测试用例的<strong>通用化</strong>和<strong>复用化</strong>则会使软件测试易于开展，并随着测试用例的不断精化其效率也不断攀升。</p><h1 id="三、黑盒测试方法" tabindex="-1">三、黑盒测试方法 <a class="header-anchor" href="#三、黑盒测试方法" aria-label="Permalink to &quot;三、黑盒测试方法&quot;">​</a></h1><p><strong>1</strong>、等价类划分法</p><p><strong>2</strong>、边界值分析法</p><p><strong>3</strong>、错误推测法</p><p><strong>4</strong>、因果图设计法</p><p><strong>5</strong>、判定表驱动法</p><p><strong>6</strong>、场景法</p><p><strong>7</strong>、正交实验法</p><p><strong>8</strong>、功能图法</p><p>下一篇文章将围绕着<strong>黑盒测试的八大方法</strong>展开细述。 如果想查看往期文章，也可以直接点击进入<a href="https://blog.csdn.net/weixin_44803753/category_10923158.html?spm=1001.2014.3001.5482" target="_blank" rel="noreferrer">软件测试栏目</a>。 码字不易，如果这篇文章对你有用，记得留个<strong>Star</strong>哦~</p>',31),a=[e];function g(l,i,p,h,c,d){return r(),o("div",null,a)}const m=t(s,[["render",g]]);export{u as __pageData,m as default};
