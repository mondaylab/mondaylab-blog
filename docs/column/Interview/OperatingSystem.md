---
title: 「offer来了」进程线程有啥关系？10个知识点带你巩固操作系统基础知识
author: 周一
date: '2021-11-10'
categories:
  - 前端开发
tags:
  - offer来了
sidebar: 'auto'
---

# 🎹 序言

操作系统对于前端来说考察的内容并不多，所以在今天的文章中将依据比较常考的知识点进行归纳总结。

下面开始本文的讲解~

# 🎸 一、思维导图

我们先用一张思维导图来梳理操作系统相关的面试题。**具体如下 👇**

![OS面试题复习框架](https://mondaylab-1309616765.cos.ap-shanghai.myqcloud.com/images/202305270821730.png)

下面开始归纳操作系统常见的面试题。

# 🎺 二、常见面试题

## 1、进程和线程以及它们的区别

- **进程**是对程序运行时的封装，是系统进行**资源调度和分配**的的基本单位，实现了操作系统的并发；
- **线程**是进程的**子任务**，是**CPU 调度和分配的基本单位**，用于保证程序的实时性，实现进程内部的并发；
- 一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；
- 进程在执行过程中拥有**独立的内存单元**，而多个线程共享进程的内存。

## 2、进程间通信的几种方式

### （1）管道(pipe)及命名管道(named pipe)

- 管道可用于具有**亲缘关系**的父子进程间的通信。
- 命名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。

### （2）信号(signal)

- 信号是一种比较复杂的通信方式，用于通知和接收某个已经发生的进程事件。

### （3）消息队列

- 消息队列是消息的**链接表**，它克服了以上两种通信方式中**信号量有限**的缺点。
- 具有**写权限**的进程可以按照一定的规则向消息队列中添加新信息。
- 对消息队列有**读权限**的进程则可以从消息队列中读取信息。

### （4）共享内存

- 可以说这是**最有用的**进程间通信方式。
- 它使得多个进程可以访问**同一块内存空间**，不同进程可以及时看到对方进程中对共享内存中数据的更新。
- 这种方式需要依靠某种**同步操作**，如互斥锁和信号量等。

### （5）信号量

- 主要作为进程之间及同一种进程的不同线程之间的同步和互斥手段；

### （6）套接字

- 这是一种更为一般的进程间通信机制，它可用于网络中**不同机器之间**的进程间通信，应用非常广泛。

## 3、线程同步的方式

### （1）互斥量 Synchronized/Lock

- 采用**互斥对象机制**，只有拥有互斥对象的线程才有访问**公共资源**的权限。
- 因为互斥对象只有一个，所以可以保证**公共资源**不会被**多个线程**同时访问。

### （2）信号量 Semphare

- 它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的**最大线程数量**。

### （3）事件(信号)Wait/Notify

- 通过**通知操作**的方式来保持多线程同步，还可以方便的实现**多线程优先级**的比较操作。

## 4、什么是死锁？死锁产生的条件？

### （1）死锁的概念

- 在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。
- 通俗的讲，就是两个或多个进程**无限期的阻塞**、**相互等待**的一种状态。

### （2）死锁产生的四个必要条件

- **互斥**：至少有一个资源必须属于**非共享模式**，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止。
- **占有并等待**：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有。
- **非抢占**：进程不能被抢占，即资源只能被**进程在完成任务后**自愿释放。
- **循环等待**：若干进程之间形成一种**头尾相接**的环形等待资源关系。

### （3）处理死锁的基本策略和常用方法

- 解决死锁的基本方法主要有**预防死锁**、**避免死锁**、**检测死锁**、**解除死锁** 、**鸵鸟策略**等。

## 5、进程有哪几种状态？

**（1）就绪状态：**进程已获得除处理机以外的所需资源，等待分配处理机资源。

**（2）运行状态：**占用处理机资源运行，处于此状态的进程数小于等于 CPU 数。

**（3）阻塞状态：** 进程等待某种条件，在条件未满足之前无法执行。

## 6、线程有几种状态？

在 Java 虚拟机 中，线程从最初的创建到最终的消亡，要经历**若干个状态**：

- 创建 `(new)` 、就绪 `(runnable/start)` 、运行 `(running)` 、阻塞 `(blocked)` 、等待 `(waiting)` 、时间等待 `(time waiting)` 和 消亡 `(dead/terminated)` 。
- **在给定的时间点上，一个线程只能处于一种状态。**

## 7、段式存储管理

### （1）段式存储管理是什么？

**段式存储管理**是一种<u>符合用户视角的</u>**内存分配管理方案**。

在段式存储管理中，将程序的地址空间划分为**若干段**(segment)，如代码段、数据段、堆栈段；

这样每个进程有一个**二维地址空间**，相互独立，互不干扰。

### （2）段式管理的优缺点

- **优点**：**没有内碎片**（因为段大小可变，可通过改变段大小来消除内碎片）。
- **缺点**：但段换入换出时，**会产生外碎片**（比如 `4k` 的段换 `5k` 的段，会产生 `1k` 的外碎片）。

### （3）页式存储管理方案

**页式存储管理方案**是一种用户视角下<u>内存与物理内存相分离</u>的**内存分配管理方案**。

在页式存储管理中，将程序的逻辑地址划分为**固定大小的页** `(page)` ，而物理内存划分为**同样大小的帧**，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了**离散分离**。

### （4）页式存储管理的优缺点

- **优点**：没有外碎片（因为页的大小固定）。
- **缺点**：但会产生内碎片（一个页可能填充不满）。

## 8、进程调度策略

### （1）FCFS(先来先服务，队列实现，非抢占的)

先请求 `CPU` 的进程先分配到 `CPU` 。

### （2）SJF(最短作业优先调度算法)

平均等待时间最短，但难以知道下一个 `CPU` 区间长度。

### （3）优先级调度算法(可以是抢占的，也可以是非抢占的)

优先级越高越先分配到 `CPU` ，相同优先级先到先服务。

**存在的主要问题是**：低优先级进程无穷等待 `CPU` ，会导致无穷阻塞或饥饿。

**解决方案**：老化（即对超过一定时间还未使用的进程进行删除）。

### （4）时间片轮转调度算法(可抢占的)

队列中没有进程被分配超过一个时间片的 `CPU` 时间，除非它是唯一可运行的进程。

如果进程的 `CPU` 区间超过了一个**时间片**，那么该进程就被抢占并放回就绪队列。

### （5）多级队列调度算法

将**就绪队列**分成多个**独立的队列**，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。

其中，一个进程根据自身属性被永久地分配到一个队列中。

### （6）多级反馈队列调度算法

与多级队列调度算法相比，其允许进程在**队列之间**移动：若进程使用过多 `CPU` 时间，那么它会被转移到更低的**优先级队列**。

在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。

## 9、页面调度算法

**FIFO 先进先出算法**：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）。

**LRU(Least recently use)最近最少使用算法**：根据<u>开始使用时间到现在为止</u>的**时间长短**来判断。

**LFU(Least frequently use)最少使用次数算法**：根据**使用次数**来判断。

**OPT(Optimal replacement)最优置换算法**：理论的最优，所谓理论，就是要保证置换出去的是**不再被使用的页**，或者是在实际内存中最晚使用的页。

## 10、局部性原理

**（1） 时间上的局部性**：**最近被访问的页**在不久的将来还会被访问。

**（2）空间上的局部性**：**内存中被访问的页**周围的页也很可能被访问。

# 🎻 三、结束语

大家可以看到，对于操作系统的面试来说，基本上都在围绕着进程和线程这两个概念交谈。所以在学习的过程中，可以以这两个点来作为主线来对知识点进行扩充和归纳。

关于操作系统的面经归纳到这里就结束啦！希望对大家有帮助~

